#!/bin/sh
# Minimal interactive commit type prompt for Conventional Commits
# Works on Alpine (BusyBox ash). No deps.

# Arguments from Git:
#   $1: path to the commit message file
#   $2: commit source (message, template, merge, squash, commit, etc.)
#   $3: SHA (when amending, etc.)
MSG_FILE="$1"
SOURCE="${2-}"

# Skip for merges/squashes, or when message already provided with -m/-F
case "$SOURCE" in
  merge|squash|message) exit 0 ;;
esac

# If message already starts with a conventional prefix, do nothing
# e.g., feat: ..., fix(scope): ...
if [ -s "$MSG_FILE" ] && grep -Eq '^[a-z]+(\([^)]+\))?: ' "$MSG_FILE"; then
  exit 0
fi

# Allow users to bypass interactively (e.g., CI) with env var
if [ "${SKIP_TYPE_PROMPT-}" = "1" ]; then
  exit 0
fi

# List of allowed types (edit to taste)
TYPES="feat fix docs style refactor perf test chore ci build revert other"

# Use /dev/tty so we can prompt even if stdin is redirected by Git
TTY="/dev/tty"
if [ ! -t 0 ] && [ ! -r "$TTY" ]; then
  # No terminal available; default to 'chore'
  TYPE="chore"
else
  # Print menu
  i=1
  printf "\nSelect a commit type:\n" >"$TTY"
  for t in $TYPES; do
    printf "  %d) %s\n" "$i" "$t" >"$TTY"
    i=$((i+1))
  done

  COUNT=$((i-1))
  # Prompt until valid
  while :; do
    printf "Enter 1-%d (default 1): " "$COUNT" >"$TTY"
    IFS= read -r CHOICE <"$TTY" || CHOICE=""
    [ -z "$CHOICE" ] && CHOICE=1
    case "$CHOICE" in
      *[!0-9]*|'') VALID= ;;
      *) [ "$CHOICE" -ge 1 ] && [ "$CHOICE" -le "$COUNT" ] && VALID=1 ;;
    esac
    [ -n "$VALID" ] && break
    printf "Invalid choice. Try again.\n" >"$TTY"
  done

  # Map number to type
  idx=1
  for t in $TYPES; do
    if [ "$idx" -eq "$CHOICE" ]; then TYPE="$t"; break; fi
    idx=$((idx+1))
  done
fi

# Prefix the first line with "TYPE: " while preserving any existing content
TMP="$(mktemp)"
# If the file starts empty, just write the prefix and a space for the user to continue
FIRST_LINE="$(sed -n '1p' "$MSG_FILE")"
if [ -z "$FIRST_LINE" ]; then
  printf "%s: " "$TYPE" >"$TMP"
  tail -n +1 "$MSG_FILE" >>"$TMP" 2>/dev/null || true
else
  # Prepend to the first line
  {
    printf "%s: %s\n" "$TYPE" "$FIRST_LINE"
    sed -n '2,$p' "$MSG_FILE"
  } >"$TMP"
fi

cat "$TMP" >"$MSG_FILE"
rm -f "$TMP"
